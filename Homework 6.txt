Задание 1
Найдите информацию о том, как в Ubuntu открыть порт 80,443. Укажите как.

$sudo iptables -A INPUT -i eth0 -p TCP --dport 22 -j ACCEPT 
$sudo iptables -A OUTPUT -o eth0 -p TCP --sport 22 -j ACCEPT

$sudo iptables -A INPUT -i eth0 -p TCP --dport 443 -j ACCEPT 
$sudo iptables -A OUTPUT -o eth0 -p TCP --sport 443 -j ACCEPT


Установить nginx, сконфигурировать свой виртуальный хост, используя порт 80, так, чтобы:
на запрос клиента с указанным и непустым хидером 'User',
oтправлять код 200 с текстом "Hi $user!", где $user - это значение хидера 'User'. Иначе отправлять код 404 с текстом "Page not found".
Мне прислать конфиг nginx и команду curl, которую выполняете.

$sudo apt-get install nginx

Конфиг site.ru:

server {
       listen 80;
       listen [::]:80; 

       server_name site.ru;

       location / {
        if ($http_user = ""){
		return 404 "Page not found.\n";
	}
	return 200 "Hi, ${http_user}!\n";
       
       }
}

Команда curl:

curl -H "Host: site.ru" -H "User: Username" http://localhost
______________________________________________________________

Задание 2
Найти информацию о том, что такое самоподписанные сертификаты и сгенерировать такой для своего вэб сервера.
Написать своими словами, что это такое и как сгенерить.

Сущестуют CA (Certefication Authority) - т.е. сертификационные центры, которые в свою очередь выдают сертефикаты.
Владелец сайта выпускает приватный и публичный ключи и подпиывает публичный ключ у удостоверяющего центра.
Т.е. по факту СА подписывают публичный ключ владельца сайта, и в ответ отправляют сертификат, что бы браузер мог проверить,
что сайт является тем, за кого себя выдает.
Публичные ключи сертификационных центров импортируются в браузеры производителем и достоверность
сертификатов выпущенных СА не должнa вызывать сомнений.

Сначала создадим собственный центр сертификации (CA). Для этого добавим частный ключ для CA:
# cd /etc/nginx/
# mkdir ssl
# chmod 700 ssl
# cd ssl
# openssl genrsa -des3 -out my-ca.key

Вводим секретую фразу к центру сертификации. Создаем сертификат:
# openssl req -new -x509 -days 3650 -sha256 -key my-ca.key -out my-ca.crt 

Вводим пароль и отвечаем на вопросы. Создаем ключ для Nginx:
# openssl genrsa -des3 -out my-nginx.key 1024

Потребуется ввести секретную фразу. Ее мы удалим из сертификата сервера Apache, чтобы она не запрашивалась при каждом старте:
# openssl rsa -in my-nginx.key -out new.my-nginx.key
# mv new.my-nginx.key my-nginx.key

Создаем запрос на подпись сертификата Certificate Signature Request (csr), чтобы подписать в центре сертификации:
# openssl req -new -key my-nginx.key -out my-nginx.csr

Раньше необходимо было поместить в поле Common name FQDN доменное имя — например, test.tst. 
Сейчас используются только значения DNS.1, DNS.2 (и так далее) в секции [ alt_names ], 
так как в поле Common name можно было указать только одно доменное имя. 
Более того, сейчас Google Chrome даже не пытается анализировать поле Common name.

Поэтому понадобится сделать еще ряд дополнительных действий (до выполнения шагов, изложенных выше), 
либо использовать скрипт генерации сертификата.

Pедактируем файл /etc/ssl/openssl.cnf:
$vim /etc/ssl/openssl.cnf

Раскомментируем строку:
req_extensions = v3_req

Дальше нужно найти секцию [ v3_req ] (пробелы имеют значение). Найдите в разделе такие строки:
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment

Сразу под ними допишем следующее: 
subjectAltName = @alt_names
[ alt_names ]
DNS.1 = www.server.com
DNS.2 = server.com
DNS.3 = admin.server.com

Секция alt_names будет содержать альтернативные имена доменов, которые требуется включить в сертификат. 
Нужно заменить их на свои. После этой операции нужно вернуться на три шага назад, сгенерировать my-nginx.key и csr.

Теперь подпишем сертификат в центре сертификации:
# openssl x509 -req -in my-nginx.csr -out my-nginx.crt -sha256 -CA my-ca.crt -CAkey my-ca.key -CAcreateserial -days 36
# chmod 0400 *.key
_______________________________________________________________________________________________________________
Добавить SSL соединение для дефолтного виртуального хоста nginx, используя порт 443. Прикрепить конфиги nginx.

Далее прописывал в nginx.conf:
http{
    ssl_protocols     SSLv3 TLSv1;
    ssl_certificate       /etc/nginx/ssl/my-nginx.crt;
    ssl_certificate_key   /etc/nginx/ssl/my-nginx.key;
    ssl_session_cache   shared:SSL:10m;
    ssl_session_timeout 5m;
    ssl_prefer_server_ciphers on;
    resolver 8.8.8.8;
    ...

В конфиг сайта добавить:
server {
	listen 443 ssl;

Или можно, например, создать файл ssl.conf где-нибудь в /etc/nginx и прописать в нем например:

listen 443 ssl;
ssl_protocols     SSLv3 TLSv1;
ssl_certificate       /etc/nginx/ssl/my-nginx.crt;
ssl_certificate_key   /etc/nginx/ssl/my-nginx.key;

В конфиг сайта добавить:

server {
       include /etc/nginx/ssl.conf;
       ...
____________________________________________________________________________________________________________________________
Откройте в браузере страницу хоста и посмотрите, как браузер реагирует на самоподписанные сертификаты. Напишите, что видите.

На хостовой машине браузер пишет, что соединение не безопасно. Если открыть информацию о сертификате, 
то есть информация о том кем он выдан и кому, срок действия и надпись о том, 
что недостаточно информации для проверки этого сертификата.

На виртуалке firefox выдал почти то же самое + информацию о тех полях, которые мы заполняли создавая сертификат.
_____________________________________________________________________________________________________________________________
Мы говорили о необходимости шифровать симметрично. При этом проблем с получением ассиметричных сертификатов нет.
Зачем такая сложная схема для установления SSL соединения? Почему бы не шифровать ассиметрично? Своими словами.

Скорее всего дело в быстроте. Симметричное шифрование, которое предшествует асимметричному, 
представляет собой одну большую проблему безопасности - распределение ключей. Это означает, что любой, 
кто отслеживает трафик, может перехватить ключи, а затем расшифровать любое зашифрованное соединение.
Проблема решается благодаря инфраструктуре общих ключей, где обеим сторонам не нужно обмениваться ключами сеанса,
т.к. ключ получателя расшифровывается только им самим.

Хоть ассиметричное шифрование в теории является более надежным, но оно так же не безупречно. Для шифровки и расшифровки
информации требуется больше вычислений и времени, а ключи должны быть очень длинными, чтобы обеспечить безопасность не хуже,
чем в симметричном шифровании (например, размер симметричного ключа в 80 бит будет равен RSA 1024-битному ключу). 
Вот почему некоторые протоколы (например, SSL/TLS) предпочитают использовать сочетание сразу двух.
_____________________________________________________________________________________________________________________________
Задание 3 *
Сейчас почти все сетевые провайдеры предоставляют клиентам белые адреса по умолчанию. Если у вас белый адрес, 
то нужно сделать ваш дефолтный виртуальный хост nginx доступным извне:
Разберитесь и сделайте проброс портов на вашем роутере (с публичного белого адреса на внутренний адрес компьютера)
в настройках Virtual Box / VMWare cделайте проброс портов с вашего компьютера на виртуальную машину,
либо переведите сетевой интерфейс виртуальный машины в режим bridged и сделайте правки к конфигурации роутера.
Разберитесь с тем, что такое файл /etc/hosts (в Windows c:\Windows\System32\Drivers\etc\hosts)
и сделайте свой сайт доступным по адресу https://geekbrains-linux.ru

Вроде бы так:

В PowerShell:
route add 172.0.0.0 mask 255.0.0.0 192.168.65.130

Запись в /etc/hosts:
192.168.65.130 geekbrains-linux.ru
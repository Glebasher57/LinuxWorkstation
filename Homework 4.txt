1. Написать регулярное выражение, которое проверяет валидный IP-адрес. Например, 192.168.1.1 подойдет, а 256.300.1.1 — нет.
	
	/^(\d|\d{2}|\d{2}[^6-9])\.\d{1,3}\.\d{1,3}\.\d{1,3}$/gmi //проверка валидности ip - не больше 255 вначале строки
	
	//если ip адреса записаны в 1 строку, то не получается сделать точную проверку.
	например: 256.300.1.1 192.168.1.1 256.300.1.1 192.168.1.1 (т.к.строка начинается с 256 ничего далее выделено не будет)
	если: 192.168.1.1 256.300.1.1 192.168.1.1 (строка начинается с 192, далее идет 256 в середине. Первый ip адрес будет выделен,
	последний нет, т.к. в середине 256. Если убрать якорь начала строки, то все вроде бы корректно выделяется, но например в 256.300.1.1 будет
	выделяться часть 56.300.1.1, а 2 откидываться и поэтому тоже мимо. Не смог сделать так, что бы выделялось все верно во всех местах.)
	
	/^192\..*\d$/gmi (такой вариант выделит полностью строку, которая будет начинаться с 192 и будет выделять часть строки: 
			  - 256.300.1.1 [192.168.1.1 256.300.1.1 192.168.1.1], которая будет начинаться с 256)

	/^(?=192).*\d$/gmi (такой тоже)

	/^(?!256).*\d$/gmi (такой тоже)

2. Написать регулярное выражение, которое проверяет, является ли указанный файлом нужного типа (на выбор .com,.exe или .jpg,.png,.gif и т.д.).
	
	/.*?(\.jpg|\.jpeg|\.png)/gmi (минус только в том, что, если опять таки, в одной строке будут находиться названия нескольких файлов 
				      по типу: file.exe, file.png, file.png
				      то строка выделится как: [file.exe file.png] вместе, следующий [file.png] отделит нормально.)

Написать регулярное выражение для проверки, ведет ли ссылка URL на некоторый файл, и это действительно ссылка на картинку
(например, http://site.com/folder/1.png), а не на любой файл.

	/\w{4,5}\:\/\/.*?\.\w{2,3}\/.*?\.(jpg|png|jpeg)/gmi

	или может быть так, если использовать поиск (но нужно ли)

	/(?=(\w{4,5}\:\/\/.*?\.\w{2,3}\/.*?\.(jpg|png|jpeg)))/gmi

3. *Написать регулярное выражение, которое проверяет, является выведенное значение «белым» IP-адресом (5.255.255.5 подойдет, а 172.16.0.1 — нет).
	
	^(?!10|172\.1[6-9]|172\.2|172\.3[0-1]|192\.168|25[5-9])(?:(\d{1,3})\.){3}(?:\d{1,3})$

4. *Написать регулярное выражение, которое проверяет, 
что файл в URL (например, https://site.ru/folder/download/test.docx) не обладает неким расширением 
(например .exe не пройдет, или .sh — не пройдет. Выбор списка исключенных расширений за вами).

	/w{4,5}\:\/\/.*?\.\w{2,3}\/.*?\.(?=docx|cfg|sh|exe)/gmi

5. Задание от немцев.
У вас есть лог log.txt, который содержит запросы на загрузку файлов. Один запрос на одной строке. IP адрес во втором столбце. 
Имя файла может быть в любом столбце. Столбцы разделены одним или несколькими пробелами. Нужно написать выражение в одну строку, 
которое выведет список всех IP адресов за исключением loopback интерфейсов, с которых запрашивался файл /closeio.html, 
а также количество таких запросов для каждого адреса. Результат должен быть отсортирован по этому значению. 
Можно использовать стандартные тулы, которые запустятся на большинстве UNIX системах.

Непубличныыми адресами будем считать вот эти сети
0.0.0.0/8
127.0.0.1/8
169.254.0.0/16
172.16.0.0/12
192.168.0.0/16
10.0.0.0/8 
255.255.255.255